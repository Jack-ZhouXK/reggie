# 项目笔记

## 一.软件开发流程

### 1.1 开发流程

>- 需求分析: 获取产品原型,需求规格说明书
>- 设计: 产品文档,`UI`界面设计,概要设置,详细设计,数据库设计
>- 编码: 项目代码,单元测试
>- 测试: 测试用例,测试报告
>- 上线运维: 软件环境安装,配置

### 1.2 角色分工

> - 产品经理
> - 项目经理
> - 开发人员(前端,后端)
> - 测试人员
> - 架构师
> - 运维人员

### 1.3 环境介绍

>- 开发环境(development): 开发阶段使用的环境,一般外部用户无法访问
>- 测试环境(testing):  专门给测试人员使用的环境,用于测试项目,外部也无法访问
>- 生产环境(production): 线上环境,正式提供服务

## 二.瑞吉外卖项目分析

### 2.1 项目介绍

>本项目是专门为餐饮企业定制的一款软件产品,包括系统管理后台和移动端应用两部分,其中系统管理后台主要提供给餐饮企业内部员工使用,可以对餐厅的菜品,套餐,订单等进行管理维护
>
>移动端应用主要提供给消费者使用,可以在线浏览菜品,添加购物车,下单等

![image-20220604183614950](E:\黑马学习\阶段五\01 瑞吉外卖\笔记.assets\image-20220604183614950.png)

**版本介绍**

>第一期:  主要实现基本功能,其中移动端应用通过`H5`页面实现,用户可以通过手机浏览器访问
>
>第二期:  主要针对移动端应用进行改进,使用微信小程序实现,用户使用起来更加方便
>
>第三期:  主要针对系统进行优化升级,提高系统的访问性能



### 2.2 技术选型

![image-20220604181929482](E:\黑马学习\阶段五\01 瑞吉外卖\笔记.assets\image-20220604181929482.png)

### 2.3 功能架构

![image-20220604181808073](E:\黑马学习\阶段五\01 瑞吉外卖\笔记.assets\image-20220604181808073.png)

### 2.4 项目角色

>- 后台系统管理员: 登录后台管理系统,拥有后台系统中的所有操作权限
>- 后台系统普通员工: 登录后台管理系统,对菜品,套餐,订单等进行管理
>- C端用户: 登录移动端应用,可以浏览菜品,添加购物车,设置地址,在线下单等



## 三.开发环境搭建

### 3.1 数据库环境搭建

>1. 创建数据库 `reggie`,执行资料中`sql`文件即可

```sql
-- 或者使用命令
-- 运行sql脚本指令
source D:\reggie.sql   --  写自己的文件路径 (不要放到中文目录下!!!!!!!!!!!!!!!!!!!!!!!!!!!!)
```

**表结构**

| **序号** | **表名**       | **说明**         |
| -------- | -------------- | ---------------- |
| 1        | employee       | 员工表           |
| 2        | category       | 菜品和套餐分类表 |
| 3        | dish           | 菜品表           |
| 4        | `setmeal`      | 套餐表           |
| 5        | `setmeal_dish` | 套餐菜品关系表   |
| 6        | dish_flavor    | 菜品口味关系表   |
| 7        | user           | 用户表（C端）    |
| 8        | address_book   | 地址簿表         |
| 9        | shopping_cart  | 购物车表         |
| 10       | orders         | 订单表           |
| 11       | order_detail   | 订单明细表       |

### 3.2 maven搭建

1. 创建Maven项目/或者直接创建`SpringBoot`,看个人

2. 引入`pom`依赖

   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <project xmlns="http://maven.apache.org/POM/4.0.0"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
       <modelVersion>4.0.0</modelVersion>
       <!-- 集成SpringBoot-->
       <parent>
           <groupId>org.springframework.boot</groupId>
           <artifactId>spring-boot-starter-parent</artifactId>
           <version>2.4.5</version>
           <relativePath/> <!-- lookup parent from repository -->
       </parent>
       <groupId>com.itheima</groupId>
       <artifactId>reggie_take_out</artifactId>
       <version>1.0-SNAPSHOT</version>
       <properties>
           <java.version>1.8</java.version>
       </properties>
       <!--    项目依赖-->
       <dependencies>
           <dependency>
               <groupId>org.springframework.boot</groupId>
               <artifactId>spring-boot-starter</artifactId>
           </dependency>
           <dependency>
               <groupId>org.springframework.boot</groupId>
               <artifactId>spring-boot-starter-test</artifactId>
               <scope>test</scope>
           </dependency>
           <dependency>
               <groupId>org.springframework.boot</groupId>
               <artifactId>spring-boot-starter-web</artifactId>
               <scope>compile</scope>
           </dependency>
           <!-- mybatis-plus -->
           <dependency>
               <groupId>com.baomidou</groupId>
               <artifactId>mybatis-plus-boot-starter</artifactId>
               <version>3.4.2</version>
           </dependency>
           <!--lombok-->
           <dependency>
               <groupId>org.projectlombok</groupId>
               <artifactId>lombok</artifactId>
               <version>1.18.20</version>
           </dependency>
           <!--对象转JSON-->
           <dependency>
               <groupId>com.alibaba</groupId>
               <artifactId>fastjson</artifactId>
               <version>1.2.76</version>
           </dependency>
           <!--通用工具类-->
           <dependency>
               <groupId>commons-lang</groupId>
               <artifactId>commons-lang</artifactId>
               <version>2.6</version>
           </dependency>
           <!--mysql数据源-->
           <dependency>
               <groupId>mysql</groupId>
               <artifactId>mysql-connector-java</artifactId>
               <scope>runtime</scope>
           </dependency>
           <!--数据库连接池-->
           <dependency>
               <groupId>com.alibaba</groupId>
               <artifactId>druid-spring-boot-starter</artifactId>
               <version>1.1.23</version>
           </dependency>
       </dependencies>
       <build>
           <plugins>
               <plugin>
                   <groupId>org.springframework.boot</groupId>
                   <artifactId>spring-boot-maven-plugin</artifactId>
                   <version>2.4.5</version>
               </plugin>
           </plugins>
       </build>
   </project>
   ```

   **导入yml文件**

```yml
server:
  port: 8080
spring:
  application: #应用名称
    name: reggie_take_out
  datasource:
    druid:
      driver-class-name: com.mysql.cj.jdbc.Driver
      url: jdbc:mysql://localhost:3306/reggie?serverTimezone=Asia/Shanghai&useUnicode=true&characterEncoding=utf-8&zeroDateTimeBehavior=convertToNull&useSSL=false&allowPublicKeyRetrieval=true
      username: root
      password: 123
mybatis-plus:
  configuration:
    #在映射实体或者属性时，将数据库中表名和字段名中的下划线去掉，按照驼峰命名法映射
    map-underscore-to-camel-case: true
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl   #开启Mybatis日志
  global-config:
    db-config:
      id-type: ASSIGN_ID  #主键生成策略
```

3. 创建启动类,名字可以自己写

   ![image-20220604185942061](E:\黑马学习\阶段五\01 瑞吉外卖\笔记.assets\image-20220604185942061.png)

4. 编写启动类

```java
package pers.zhou.reggle;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
@SpringBootApplication
@Slf4j // 可以直接使用log日志
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
        log.info("项目启动成功.....");
    }
}
```

5. 启动`SpringBoot`

![image-20220604190044135](E:\黑马学习\阶段五\01 瑞吉外卖\笔记.assets\image-20220604190044135.png)

6. 导入前端页面(资料文件夹中前端资料中)

   - front: 前端展示
   - background: 管理端展示

   默认`SpringBoot`是访问不到除了template/static之外的资源的,两种方式解决

   1. 手动创建static或者template文件夹,把资源放入其中
   2. 通过SpringBoot配置文件夹相关的映射路径

   第一种比较简单,我重点说下第二种

   >前置知识: `WebMvcConfigurationSupport`
   >
   >```text
   >WebMvcConfigurationSupport是webmvc的配置类，如果在springboot项目中，
   >有配置类继承了WebMvcConfigurationSupport，那么webmvc的自动配置类WebMvcAutoConfiguration就会失效。
   >```
   >
   >```java
   >package pers.zhou.reggle.config;
   >
   >import lombok.extern.slf4j.Slf4j;
   >import org.springframework.context.annotation.Configuration;
   >import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
   >import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;
   >
   >@Configuration //声明是一个配置类
   >@Slf4j
   >public class WebMvcConfig extends WebMvcConfigurationSupport {
   >    /**
   >     * 设置静态资源映射
   >     */
   >    @Override
   >    protected void addResourceHandlers(ResourceHandlerRegistry registry) {
   >        log.info("开始进行静态资源映射");
   >        // 请求包含backend/**通配， 映射到backend下面
   >        registry.addResourceHandler("/backend/**").addResourceLocations("classpath:/backend/");
   >        registry.addResourceHandler("/front/**").addResourceLocations("classpath:/front/");
   >    }
   >}
   >```



## 四.项目开发

### 4.1 后台登录功能

登录页面展示（页面位置：项目/resources/`backend`/page/login/`login.html`）,目前没有配置路由

登录接口: `http://localhost:8080/employee/login` 

参数: `username`和`password`

1. 生成实体类,我这里直接使用easyCode具体操作如下

   - 下载easyCode插件
   - ![image-20220604192924487](E:\黑马学习\阶段五\01 瑞吉外卖\笔记.assets\image-20220604192924487.png)
   - ![image-20220604193221495](E:\黑马学习\阶段五\01 瑞吉外卖\笔记.assets\image-20220604193221495.png)
   - ![image-20220604193258729](E:\黑马学习\阶段五\01 瑞吉外卖\笔记.assets\image-20220604193258729.png)
   - ![image-20220604193344361](E:\黑马学习\阶段五\01 瑞吉外卖\笔记.assets\image-20220604193344361.png)
   - ![image-20220604193520091](E:\黑马学习\阶段五\01 瑞吉外卖\笔记.assets\image-20220604193520091.png)
   - 选中所有表格,一键生成所有实体类,点击`ok`,文件就生成好啦,当然这个也可以一键生成 service controller,mapper 但是新手建议手敲

2. 创建 controller,service,serviceImpl,Mapper 分别集成Mybatis-Plus提供的接口

   **controller**

   ```JAVA
   package pers.zhou.reggle.controller;
   import lombok.extern.slf4j.Slf4j;
   import org.springframework.beans.factory.annotation.Autowired;
   import org.springframework.web.bind.annotation.RequestMapping;
   import org.springframework.web.bind.annotation.RestController;
   import pers.zhou.reggle.service.serviceimpl.EmployService;
   @Slf4j //日志
   @RestController
   @RequestMapping("/employee") 
   public class EmployeeController {
       @Autowired
       private EmployService employService;
   }
   ```

   **entity就不写了,因为比较长还没有营养,你如果按照生成器生成的话,那么你的entity里面应该已经有一个Employee了**

   **service**

   ```JAVA
   import com.baomidou.mybatisplus.extension.service.IService;
   import pers.zhou.reggle.entity.Employee;
   
   public interface EmployService extends IService<Employee> {
   }
   ```

   **serviceImpl**

   ```java
   @Service
   public class EmployeeServiceImpl extends ServiceImpl<EmployeeMapper, Employee> implements EmployService {
   }
   ```

   **mapper**

   ```java
   @Mapper
   public interface EmployeeMapper extends BaseMapper<Employee> {
   }
   ```

2. 设置通用结果返回

   ```Java
   package pers.zhou.reggle.common;
   import lombok.Data;
   import java.util.HashMap;
   import java.util.Map;
   /**
    * 通用返回结果
    * @param <T>
    */
   @Data
   public class R<T> {
       private Integer code; //编码：1成功，0和其它数字为失败
       private String msg; //错误信息
       private T data; //数据
       private Map<Object,Object> map = new HashMap<>(); //动态数据
       public static <T> R<T> success(T object) {
           R<T> r = new R<T>();
           r.data = object;
           r.code = 1;
           return r;
       }
       public static <T> R<T> error(String msg) {
           R r = new R();
           r.msg = msg;
           r.code = 0;
           return r;
       }
       public R<T> add(String key, Object value) {
           this.map.put(key, value);
           return this;
       }
   }
   ```

3. 处理登录逻辑

   >1、将页面提交的密码password进行`md5`加密处理
   >2、根据页面提交的用户名`username`查询数据库
   >3、如果没有查询到则返回登录失败结果
   >4、密码比对，如果不一致则返回登录失败结果
   >5、查看员工状态，如果为已禁用状态，则返回员工已禁用结果
   >6、登录成功，将员工id存入Session并返回登录成功结果

   ![image-20220604195834650](E:\黑马学习\阶段五\01 瑞吉外卖\笔记.assets\image-20220604195834650.png)

4. 测试代码   完美运行~      

5. 打开`F12` ,点击Application,查看Local Storage 看到存到相关信息

### 4.2 退出功能开发

**需求分析**	

>员工登录成功后，页面跳转到后台系统首页面(backend/index.html)，此时会显示当前登录用户的姓名：
>如果员工需要退出系统，直接点击右侧的退出按钮即可退出系统，退出系统后页面应跳转回登录页面

**代码开发**

请求地址: /employee/logout

请求方式: POST

处理逻辑：
1、清理Session中的用户id
2、返回结果

```java
/**
 * 员工退出
 */
@PostMapping("/loginOut")
public R<String> loginOut(HttpServletRequest request) {
    request.getSession().removeAttribute("employee"); //清理Session中的用户id
    return R.success("退出成功");
}
```

测试代码: 完美运行~    Local Storage 同时清空

### 4.3 完善登录拦截

**需求分析**

>前面我们已经完成了后台系统的员工登录功能开发，但是还存在一个问题：用户如果不登录，直接访问系统首页面，照样可以正常访问。
>这种设计并不合理，我们希望看到的效果应该是，只有登录成功后才可以访问系统中的页面，如果没有登录则跳转到登录页面。
>
>可以使用过滤器或者拦截器，在过滤器或者拦截器中判断用户是否已经完成登录，如果没有登录则跳转到登录页面。

**实现步骤**

>1、创建自定义过滤器`LoginCheckFilter`
>2、在启动类上加入注解`@ServletComponentScan`
>3、完善过滤器的处理逻辑

**处理逻辑**

>1、获取本次请求的URI
>2、判断本次请求是否需要处理
>3、如果不需要处理，则直接放行
>4、判断登录状态，如果已登录，则直接放行
>5、如果未登录则返回未登录结果,通过输出流向页面响应数据

**编写代码**

`LoginCheckFilter`

```java
import com.alibaba.fastjson.JSON;
import lombok.extern.slf4j.Slf4j;
import org.springframework.util.AntPathMatcher;
import pers.zhou.reggle.common.R;
import javax.servlet.*;
import javax.servlet.annotation.WebFilter;
import javax.servlet.http.HttpServletRequest;
import java.io.IOException;
/**
 * 检查用户是否登录
 * filterName: 过滤器名称
 * urlPatterns：什么请求会被拦截   /*代表所有
 */
@Slf4j
@WebFilter(filterName = "loginCheckFilter", urlPatterns = "/*")
public class LoginCheckFilter implements Filter {

    // 路径匹配器
    public static final AntPathMatcher PATH_MATCHER = new AntPathMatcher();

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        HttpServletRequest request = (HttpServletRequest) servletRequest;
        String requestURI = request.getRequestURI();  //获取本次请求的URI
        String[] urls = new String[]{
                "/employee/login",
                "/employee/logout",
                "/backend/**",
                "front/**"};

        //判断本次请求是否需要处理
        if (check(urls, requestURI)) {  //如果不需要处理，则直接放行
            filterChain.doFilter(servletRequest, servletResponse);
            return;
        }
        //判断登录状态，如果已登录，则直接放行
        if (request.getSession().getAttribute("employee") != null) {
            filterChain.doFilter(servletRequest, servletResponse);
            return;
        }
        //如果未登录则返回未登录结果,通过输出流向页面响应数据
        servletResponse.getWriter().write(JSON.toJSONString(R.error("NOTLOGIN")));
        return;
    }
    /**
     * 检查本次请求是否需要放行
     */
    public boolean check(String[] urls, String requestURI) {
        for (String url : urls) {
            if (PATH_MATCHER.match(url, requestURI)) {
                return true;
            }
        }
        return false;
    }
}
```

`Application`

```java
@SpringBootApplication
@Slf4j // 可以直接使用log日志
@ServletComponentScan // 扫描ServletFilter
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
        log.info("项目启动成功.....");
    }
}
```



### 4.4 员工管理开发

#### Ⅰ. 新增员工

**需求分析 **

>后台系统中可以管理员工信息，通过新增员工来添加后台系统用户。点击[添加员工]按钮跳转到新增页面

>新增员工，其实就是将我们新增页面录入的员工数据插入到employee表。
>
>需要注意，employee表中对`username`字段加入了唯一约束，因为`username`是员工的登录账号，必须是唯一的
>
>employee表中的status字段已经设置了默认值1，表示状态正常。

**代码开发**

程序执行过程

>1、页面发送ajax请求，将新增员工页面中输入的数据以json的形式提交到服务端
>2、服务端Controller接收页面提交的数据并调用Service将数据进行保存
>3、Service调用Mapper操作数据库，保存数据

请求接口:  employee/save

请求数据: Employee `JSON`数据

```java
/**
 * 新增员工
 */
@PostMapping
public R<String> save(HttpServletRequest request, @RequestBody Employee employee) {
    log.info("新增员工，员工信息：{}", employee.toString());
    //设置初始密码123456，进行md5加密处理
    employee.setPassword(DigestUtils.md5DigestAsHex("123456".getBytes()));
    employee.setCreateTime(LocalDateTime.now());
    employee.setUpdateTime(LocalDateTime.now());
    Long userId = (Long) request.getSession().getAttribute("employee"); //当前登录用户的ID
    employee.setCreateUser(userId);
    employee.setUpdateUser(userId);
    employService.save(employee);
    return R.success("新增员工成功");
}
```

程序还存在一个问题，就是当我们在新增员工时输入的账号已经存在，由于employee表中对该字段加入了唯一约束，此时程序会抛出异常：

`java.sql.SQLIntegrityConstraintViolationException: Duplicate entry 'zxk' for key 'employee.idx_username'`

这个原因是因为`username`设置了唯一约束,所以不能重复插入两条`username`相同的数据,处理方案如下

1. 在Controller方法中加入try、catch进行异常捕获(但是局限性太大,不方便使用) 

   解决方案: 使用try-catch捕获异常处理

2. 使用异常处理器进行全局异常捕获( 我这里使用第二种)

```java
/**
 * 全局异常处理
 */
@ResponseBody
@Slf4j
@ControllerAdvice(annotations = {RestController.class, Controller.class})  //拦截带有RestController或者Controller注解的接口
public class GlobalExceptionHandler {
    /**
     * 异常处理
     */
    @ExceptionHandler(SQLIntegrityConstraintViolationException.class)
    public R<String> exceptionHandler(SQLIntegrityConstraintViolationException exception) {
        log.error("拦截异常，{}", exception.getMessage());
        // 如果sql错误中包含"Duplicate entry"关键字，证明是违反了唯一约束的错误
        if (exception.getMessage().contains("Duplicate entry")) { 
            String[] split = exception.getMessage().split(" ");//以空格进行分割 获取重复字段
            String msg = split[2] + "已存在";
            return R.error(msg);
        }
        return R.error("未知错误");
    }
}
```

#### Ⅱ. 员工信息分页查询

**需求分析**

>系统中的员工很多的时候，如果在一个页面中全部展示出来会显得比较乱，不便于查看，所以一般的系统中都会以分页的方式来展示列表数据。

**执行流程**

>1、页面发送ajax请求，将分页查询参数(page、pageSize、name)提交到服务端
>2、服务端Controller接收页面提交的数据并调用Service查询数据
>3、Service调用Mapper操作数据库，查询分页数据
>4、Controller将查询到的分页数据响应给页面
>5、页面接收到分页数据并通过ElementUI的Table组件展示到页面上

**代码编写**

>服务端要实现分页查询，可以使用Mybatis Plus提供的分页插件来简化开发

```java
package pers.zhou.reggle.config;
import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;
import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
/**
 * 配置MP分页插件
 */
@Configuration
public class MyBatisPlusConfig {
    /**
     * Mybatis拦截器
     */
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor();
        mybatisPlusInterceptor.addInnerInterceptor(new PaginationInnerInterceptor());
        return mybatisPlusInterceptor;
    }
}
```

```java
/**
 * 分页查询员工 信息
 */
@GetMapping("/page")
public R<Page<Employee>> page(int page, int pageSize, String name) {
    Page<Employee> pageEmployee = new Page<>(page, pageSize);  //构建分页构造器
    LambdaQueryWrapper<Employee> queryWrapper = new LambdaQueryWrapper<>();  //构建条件构造器
    queryWrapper.like(StringUtils.isNotEmpty(name), Employee::getName, name); // 如果name不等于空，则通过~name~模糊查询
    queryWrapper.orderByDesc(Employee::getUpdateTime);   // 通过更新时间进行排序
    employService.page(pageEmployee, queryWrapper);  //进行查询
    log.info("page:{}", page);
    return R.success(pageEmployee);
}
```

#### Ⅲ. 启用/禁用员工账号

**需求分析**

>在员工管理列表页面，可以对某个员工账号进行启用或者禁用操作。账号禁用的员工不能登录系统，启用后的员工可以正常登录。
>需要注意，只有管理员（admin用户）可以对其他普通用户进行启用、禁用操作，所以普通用户登录系统后启用、禁用按钮不显示。

**执行流程**

>1、页面发送ajax请求，将参数(id、status)提交到服务端
>2、服务端Controller接收页面提交的数据并调用Service更新数据
>3、Service调用Mapper操作数据库

**代码开发**

>启用、禁用员工账号，本质上就是一个更新操作，也就是对status状态字段进行操作
>在Controller中创建update方法，此方法是一个通用的修改员工信息的方法

```java
/**
 * 更新员工信息操作
 */
@PutMapping
public R<String> update(HttpServletRequest request, @RequestBody Employee employee) {
    log.info("更新员工信息操作：{}", employee);
    employee.setUpdateTime(LocalDateTime.now());
    employee.setUpdateUser((Long) request.getSession().getAttribute("employee"));
    employService.updateById(employee);
    return R.success("员工信息修改成功~");
}
```

**问题**

```text
测试过程中没有报错，但是功能并没有实现，查看数据库中的数据也没有变化。
SQL执行的结果是更新的数据行数为0，仔细观察id的值，和数据库中对应记录的id值并不相同
```

**原因**

>分页查询时服务端响应给页面的数据中id的值为19位数字，类型为long
>
>页面中js处理long型数字只能精确到前16位，所以最终通过ajax请求提交给服务端的时候id变为了1391586184024604700

**解决**

>我们可以在服务端给页面响应json数据时进行处理，将long型数据统一转为String字符串

**实现步骤**

>1. 提供对象转换器JacksonObjectMapper，基于Jackson进行Java对象到json数据的转换（资料中已经提供，直接复制到项目中使用）
>2. 在WebMvcConfig配置类中扩展Spring mvc的消息转换器，在此消息转换器中使用提供的对象转换器进行Java对象到json数据的转换

```java
public class WebMvcConfig extends WebMvcConfigurationSupport{
    /**
     * 消息转换器
     */
    @Override
    protected void extendMessageConverters(List<HttpMessageConverter<?>> converters) {
        log.info("扩展自定义消息转换器");
        //创建新的消息转换器对象
        MappingJackson2HttpMessageConverter jackson2HttpMessageConverter = new MappingJackson2HttpMessageConverter();
        //设置自定义对象转换器
        jackson2HttpMessageConverter.setObjectMapper(new JacksonObjectMapper());
        //将上面的消息转换器对象追加到mvc框架的转换器集合中
        converters.add(0, jackson2HttpMessageConverter);
    }
}
```

#### Ⅳ. 编辑员工信息

**需求分析**

>在员工管理列表页面点击编辑按钮，跳转到编辑页面，在编辑页面回显员工信息并进行修改，最后点击保存按钮完成编辑操作

**实现步骤**

>1、点击编辑按钮时，页面跳转到add.html，并在url中携带参数[员工id]
>2、在add.html页面获取url中的参数[员工id]
>3、发送ajax请求，请求服务端，同时提交员工id参数
>4、服务端接收请求，根据员工id查询员工信息，将员工信息以json形式响应给页面
>5、页面接收服务端响应的json数据，通过VUE的数据绑定进行员工信息回显
>6、点击保存按钮，发送ajax请求，将页面中的员工信息以json方式提交给服务端
>7、服务端接收员工信息，并进行处理，完成后给页面响应
>8、页面接收到服务端响应信息后进行相应处理

需要一个通过ID获取用户信息接口

```java
/**
 * 通过ID获取用户信息
 */
@GetMapping("/{id}")
public R<Employee> getById(@PathVariable Long id) {
    Employee employee = employService.getById(id);
    if (employee == null) {
        return R.error("当前用户不存在");
    }
    return R.success(employee);
}
```

我们无需再开发修改功能，在前面实现员工账号启用、禁用功能时已经创建了通用的编辑方法，此时还是调用此方法即可完成员工信息修改操作，所以编辑页面点击保存按钮时提交的服务端

请求地址 `localhost:8080/employee`  

请求方法`PUT`

### 4.5 分类管理业务

#### Ⅰ. 公共字段自动填充

**需求分析**

问题:

>前面我们已经完成了后台系统的员工管理功能开发，在新增员工时需要设置创建时间、创建人、修改时间、修改人等字段，在编辑员工时需要设置修改时间和修改人等字段。这些字段属于公共字段，也就是很多表中都有这些字段

解决方案:

>使用Mybatis Plus提供的公共字段自动填充功能。
>
>Mybatis Plus公共字段自动填充，也就是在插入或者更新的时候为指定字段赋予指定的值，使用它的好处就是可以统一对这些字段进行处理，避免了重复代码。

**代码实现**

>实现步骤：
>1、在实体类的属性上加入@TableField注解，指定自动填充的策略
>2、按照框架要求编写元数据对象处理器，在此类中统一为公共字段赋值，此类需要实现MetaObjectHandler接口

```java
public class Employee implements Serializable{
    /**
     * 创建时间
     */
    @TableField(fill = FieldFill.INSERT) //插入时填充字段
    private LocalDateTime createTime;
    /**
     * 更新时间
     */
    @TableField(fill = FieldFill.INSERT_UPDATE) //插入时和修改时填充字段
    private LocalDateTime updateTime;
    /**
     * 创建人
     */
    @TableField(fill = FieldFill.INSERT) //插入时填充字段
    private Long createUser;
    /**
     * 修改人
     */
    @TableField(fill = FieldFill.INSERT_UPDATE) //插入和更新时候
    private Long updateUser;
}
```

```java
/**
 * 自定义元数据处理器
 */
@Component
@Slf4j
public class MyMetaObjectHandler implements MetaObjectHandler {
    /**
     * 插入数据填充字段
     */
    @Override
    public void insertFill(MetaObject metaObject) {
        log.info("公共字段insert:{}", metaObject.toString());
        metaObject.setValue("createTime", LocalDateTime.now());
        metaObject.setValue("updateTime", LocalDateTime.now());
        metaObject.setValue("createUser", 1L);  //TODO:暂时写死 后期优化
        metaObject.setValue("updateUser", 1L);  //TODO:暂时写死 后期优化
    }

    /**
     * 更新数据填充字段
     */
    @Override
    public void updateFill(MetaObject metaObject) {
        metaObject.setValue("updateTime", LocalDateTime.now());
        metaObject.setValue("updateUser", 1L);  //TODO:暂时写死 后期优化
    }
}
```

问题:

>自动填充createUser和updateUser时设置的用户id是固定值，现在我们需要改造成动态获取当前登录用户的id。
>
>我们在MyMetaObjectHandler类中是不能获得HttpSession对象的，所以我们需要通过其他方式来获取登录用户id。

**解决方案**

>可以使用ThreadLocal来解决此问题,它是JDK中提供的一个类。

**前置知识**

>在学习ThreadLocal之前，我们需要先确认一个事情，就是客户端发送的每次http请求，对应的在服务端都会分配一个新的线程来处理，在处理过程中涉及到下面类中的方法都属于相同的一个线程：
>1、LoginCheckFilter的doFilter方法
>2、EmployeeController的update方法
>3、MyMetaObjectHandler的updateFill方法
>可以在上面的三个方法中分别加入下面代码（获取当前线程id）：
>
>```java
>long id = Thread.currentThread().getId();
>log.info("LoginCheckFilter,Thread线程id为:{}", id);
>```
>
>执行编辑员工功能进行验证，通过观察控制台输出可以发现，一次请求对应的线程id是相同的

**什么是ThreadLocal？**

>ThreadLocal并不是一个Thread，而是Thread的局部变量。当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。
>ThreadLocal为每个线程提供单独一份存储空间，具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问。
>
>ThreadLocal常用方法：
>
>```java
>public void set(T value) 	设置当前线程的线程局部变量的值
>public T get() 		返回当前线程所对应的线程局部变量的值
>```
>
>我们可以在LoginCheckFilter的doFilter方法中获取当前登录用户id，并调用ThreadLocal的set方法来设置当前线程的线程局部变量的值（用户id），然后在MyMetaObjectHandler的updateFill方法中调用ThreadLocal的get方法来获得当前线程所对应的线程局部变量的值（用户id）。

**实现步骤**

>1、编写BaseContext工具类，基于ThreadLocal封装的工具类
>2、在LoginCheckFilter的doFilter方法中调用BaseContext来设置当前登录用户的id
>3、在MyMetaObjectHandler的方法中调用BaseContext获取登录用户的id

```java
/**
 * 基于ThreadLocal封装工具类,用户保存和获取当前登录用户的ID
 */
public class BaseContext {
    private static final ThreadLocal<Long> threadLocal = new ThreadLocal<>();

    public static void setCurrentId(Long id) {
        threadLocal.set(id);
    }

    public static Long getCurrentId() {
        return threadLocal.get();
    }
}
```

```java
/**
 * 自定义元数据处理器
 */
@Component
@Slf4j
public class MyMetaObjectHandler implements MetaObjectHandler {
    /**
     * 插入数据填充字段
     */
    @Override
    public void insertFill(MetaObject metaObject) {
        log.info("公共字段insert:{}", metaObject.toString());
        metaObject.setValue("createTime", LocalDateTime.now());
        metaObject.setValue("updateTime", LocalDateTime.now());
        metaObject.setValue("createUser", BaseContext.getCurrentId());  +++++++++ 
        metaObject.setValue("updateUser", BaseContext.getCurrentId());  +++++++++
    }
    /**
     * 更新数据填充字段
     */
    @Override
    public void updateFill(MetaObject metaObject) {
        long id = Thread.currentThread().getId();
        log.info("updateFill,Thread线程id为:{}", id);
        metaObject.setValue("updateTime", LocalDateTime.now()); 
        metaObject.setValue("updateUser", BaseContext.getCurrentId());  +++++++++
    }
}
```

#### Ⅱ. 新增分类

**需求分析**

>后台系统中可以管理分类信息，分类包括两种类型，分别是菜品分类和套餐分类。当我们在后台系统中添加菜品时需要选择一个菜品分类，当我们在后台系统中添加一个套餐时需要选择一个套餐分类，在移动端也会按照菜品分类和套餐分类来展示对应的菜品和套餐。

**数据模型**

新增分类，其实就是将我们新增窗口录入的分类数据插入到category表

![image-20220605122811732](E:\黑马学习\阶段五\01 瑞吉外卖\笔记.assets\image-20220605122811732.png)

需要注意，category表中对name字段加入了唯一约束，保证分类的名称是唯一的

**执行流程**

>实体类Category
>Mapper接口CategoryMapper
>业务层接口CategoryService
>业务层实现类CategoryServiceImpl
>控制层CategoryController

>1、页面(backend/page/category/list.html)发送ajax请求，将新增分类窗口输入的数据以json形式提交到服务端
>2、服务端Controller接收页面提交的数据并调用Service将数据进行保存
>3、Service调用Mapper操作数据库，保存数据
>
>可以看到新增菜品分类和新增套餐分类请求的服务端地址和提交的json数据结构相同，所以服务端只需要提供一个方法统一处理即可

使用EasyCode生成的实体类没有@TableField注解,所以无法使用自动填充,记得自己加上即可    时间类型也需要修改

```java
/**
 * 创建时间
 */
@TableField(fill = FieldFill.INSERT) //插入时填充字段   +++++++++++++++++++++++
private LocalDateTime createTime;   +++++++++++++++++++++++
/**
 * 更新时间
 */
@TableField(fill = FieldFill.INSERT_UPDATE) //插入时和修改时填充字段  +++++++++++++++++++++++
private LocalDateTime updateTime;   +++++++++++++++++++++++
/**
 * 创建人
 */
@TableField(fill = FieldFill.INSERT) //插入时填充字段  +++++++++++++++++++++++
private Long createUser;
/**
 * 修改人
 */
@TableField(fill = FieldFill.INSERT_UPDATE) //插入和更新时候 +++++++++++++++++++++++
private Long updateUser;
```

**CategoryController**

```java
/**
 * 分类管理
 */
@RestController
@RequestMapping("/category")
@Slf4j
public class CategoryController {
    @Autowired
    private CategoryService categoryService;
    /**
     * 新增分类
     */
    @PostMapping
    public R<String> save(@RequestBody Category category) {
        log.info("新增分类category:{}", category);
        categoryService.save(category);
        return R.success("新增分类成功");
    }
}
```

**CategoryService**

```java
/**
 * 分类管理
 */
public interface CategoryService extends IService<Category> {
}
```

**CategoryServiceImpl**

```java
/**
 * 分类管理
 */
@Service
public class CategoryServiceImpl extends ServiceImpl<CategoryMapper, Category> implements CategoryService {
}
```

**CategoryMapper**

```java
/**
 * 分类管理
 */
@Mapper
public interface CategoryMapper extends BaseMapper<Category> {
}
```

#### Ⅲ. 分类信息分页查询

**需求分析**

>系统中的分类很多的时候，如果在一个页面中全部展示出来会显得比较乱，不便于查看，所以一般的系统中都会以分页的方式来展示列表数据。

**代码开发同上员工分页,这里没有特殊的,直接贴代码了**

```JAVA
/**
 * 分类信息分页查询
 */
@GetMapping("/page")
public R<Page<Category>> page(int page,int pageSize){
    Page<Category> pageInfo =  new Page<>(page, pageSize);
    LambdaQueryWrapper<Category> queryWrapper = new LambdaQueryWrapper<>();
    queryWrapper.orderByAsc(Category::getSort);
    categoryService.page(pageInfo, queryWrapper);
    return R.success(pageInfo);
}
```

#### Ⅳ. 删除分类

**需求分析**

>在分类管理列表页面，可以对某个分类进行删除操作。需要注意的是当分类关联了菜品或者套餐时，此分类不允许删除.

**执行流程**

>1、页面发送ajax请求，将参数(id)提交到服务端
>2、服务端Controller接收页面提交的数据并调用Service删除数据
>3、Service调用Mapper操作数据库

>要完善分类删除功能，需要先准备基础的类和接口
>
>1、实体类Dish和Setmeal
>2、Mapper接口DishMapper和SetmealMapper
>3、Service接口DishService和SetmealService
>4、Service实现类DishServiceImpl和SetmealServiceImpl  
>
>定义方法跟上面一致 ,这里不贴代码了

>具体实现步骤：
>1）创建自定义业务异常类
>2）在CategoryService中扩展remove方法
>3）在CategoryServiceImpl中实现remove方法
>4）在GlobalExceptionHandler中处理自定义异常

```java
package pers.zhou.reggle;
/**
 * 自定义业务异常
 */
public class CustomException extends RuntimeException{
    public CustomException(String message) {
        super(message);
    }
}
```

`GlobalExceptionHandler`

```java
/**
 * 业务异常处理
 */
@ExceptionHandler(CustomException.class)
public R<String> exceptionHandler(CustomException exception) {
    return R.error(exception.getMessage());
}
```

`CategoryController`

```JAVA

/**
 * 根据ID删除分类信息
 */
@DeleteMapping
public R<String> delete(Long id) {
    categoryService.remove(id);
    return R.success("分类信息删除成功");
}
```

```JAVA
/**
 * 分类管理
 */
public interface CategoryService extends IService<Category> {
    /**
     * 删除分类
     */
    void remove(Long id);
}
```

```JAVA
/**
 * 分类管理
 */
@Service
public class CategoryServiceImpl extends ServiceImpl<CategoryMapper, Category> implements CategoryService {
    @Autowired
    private DishService dishService;
    @Autowired
    private SetmealService setmealService;
    /**
     * 根据ID删除分类
     * 删除之前需要判断 是否关联其余菜品或者套餐
     * 如果已经关联则抛出业务异常即可
     */
    @Override
    public void remove(Long id) {
        LambdaQueryWrapper<Dish> dishLambdaQueryWrapper = new LambdaQueryWrapper<Dish>();
        dishLambdaQueryWrapper.eq(Dish::getCategoryId, id);
        if (dishService.count(dishLambdaQueryWrapper) > 0) {
            throw new CustomException("当前分类项关联了菜品,不能删除~");
        }
        LambdaQueryWrapper<Setmeal> SetmealQueryWrapper = new LambdaQueryWrapper<Setmeal>();
        SetmealQueryWrapper.eq(Setmeal::getCategoryId, id);
        if (setmealService.count(SetmealQueryWrapper) > 0) {
            throw new CustomException("当前分类项关联了套餐,不能删除~");
        }
        super.removeById(id);
    }
}
```

#### Ⅴ. 修改分类

**需求分析**

>在分类管理列表页面点击修改按钮，弹出修改窗口，在修改窗口回显分类信息并进行修改，最后点击确定按钮完成修改操作

请求接口: category

请求方式: PUT

参数: Category 对象

```java
/**
 * 修改分类信息
 */
@PutMapping
public R<String> update(@RequestBody Category category) {
    categoryService.updateById(category);
    return R.success("修改分类信息成功");
}
```



### 4.6 菜品管理开发

#### Ⅰ. 文件上传下载

>服务端要接收客户端页面上传的文件，通常都会使用Apache的两个组件：
>
>- commons-fileupload
>- commons-io
>
>Spring框架在spring-web包中对文件上传进行了封装，大大简化了服务端代码，我们只需要在Controller的方法中声明一个MultipartFile类型的参数即可接收上传的文件

**文件上传**

```java
/**
 * 文件上传和下载
 */
@RequestMapping("/common")
@Slf4j
@RestController
public class CommonController {
    @Value("${reggie.path}")
    private String filePath;
    /**
     * 文件上传
     */
    @PostMapping("/upload")
    public R<String> upload(MultipartFile file) {  //文件名称必须和前端保持一致,否则接收不到
        //file 是一个临时文件,所以需要保存到本地,否则本次上传结束后就会删除
        if (file == null) {
            return R.error("获取文件失败");
        }
        // 获取后缀
        String suffix = file.getOriginalFilename().substring(file.getOriginalFilename().lastIndexOf("."));
        //使用UUID随机生成一个名字,防止重名造成的覆盖
        String fileName = filePath + UUID.randomUUID().toString() + suffix;
        File dir = new File(filePath);
        if (!dir.exists()) {//判断当前路径是否存在
            dir.mkdirs();    //目录不存在 需要创建
        }
        try {
            file.transferTo(new File(fileName));
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        return R.success(fileName);
    }
}
```

**文件下载**

```java
/**
 * 文件下载
 */
@GetMapping("/download")
public void download(String name, HttpServletResponse response) {
    try {
        // 输入流读取文件内容
        FileInputStream fileInputStream = new FileInputStream(new File(filePath + name));
        // 输出流将文件写回浏览器
        ServletOutputStream outputStream = response.getOutputStream();
        //设置响应类型
        response.setContentType("image/jpeg");
        // 读取数据
        int len = 0;
        byte[] bytes = new byte[1024];
        while ((len = fileInputStream.read(bytes)) != -1) {
            outputStream.write(bytes, 0, len);
            outputStream.flush(); //刷新
        }
        // 关闭资源
        outputStream.close();
        fileInputStream.close();
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
}
```

#### Ⅱ. 新增菜品

**需求分析**

>后台系统中可以管理菜品信息，通过新增功能来添加一个新的菜品，在添加菜品时需要选择当前菜品所属的菜品分类，并且需要上传菜品图片，在移动端会按照菜品分类来展示对应的菜品信息。

**数据模型**

>新增菜品，其实就是将新增页面录入的菜品信息插入到dish表，如果添加了口味做法，还需要向dish_flavor表插入数据。
>
>所以在新增菜品时，涉及到两个表：
>
>| 表名 3r           | 描述       |
>| ----------------- | ---------- |
>| dish            3 | 菜品表     |
>| dish_flavor       | 菜品口味表 |

**代码开发**

>先将需要用到的类和接口基本结构创建好：
>
>- 实体类 DishFlavor
>- Mapper接口 DishFlavorMapper
>- 业务层接口 DishFlavorService
>- 业务层实现类 DishFlavorServiceImpl
>- 控制层 DishController

>梳理一下新增菜品时前端页面和服务端的交互过程：
>1、页面(backend/page/food/add.html)发送ajax请求，请求服务端获取菜品分类数据并展示到下拉框中
>2、页面发送请求进行图片上传，请求服务端将图片保存到服务器
>3、页面发送请求进行图片下载，将上传的图片进行回显
>4、点击保存按钮，发送ajax请求，将菜品相关数据以json形式提交到服务端

**查询分类数据**

>请求服务端获取菜品分类数据并展示到下拉框中，所以需要在CategoryController中提供方法，查询分类数据

**CategoryController**

```Java
/**
 * 获取菜品分类数据
 */
@GetMapping("/list")
public R<List<Category>> list(Category category) {
    LambdaQueryWrapper<Category> wrapper = new LambdaQueryWrapper<>();
    wrapper.eq(category.getType() != null, Category::getType, category.getType());
    wrapper.orderByAsc(Category::getSort).orderByDesc(Category::getUpdateTime);
    List<Category> list = categoryService.list(wrapper);
    return R.success(list);
}
```

>页面发送请求进行图片上传，请求服务端将图片保存到服务器，直接使用我们前面开发的CommonController的upload方法来处理即可。
>
>页面发送请求进行图片下载，将上传的图片进行回显，直接使用我们前面开发的CommonController的download方法来处理即可。

*点击保存按钮，发送ajax请求，将菜品相关数据以json形式提交到服务端*

>导入DishDto，用于封装页面提交的数据
>
>* DTO，全称为Data Transfer Object，即数据传输对象，一般用于展示层与服务层之间的数据传输。

**DishDto**

```java
@Data
public class DishDto extends Dish {
    private List<DishFlavor> flavors = new ArrayList<>();
    private String categoryName;
    private Integer copies;
}
```

**Application**

```java
@EnableTransactionManagement //开启事务注解支持
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
        log.info("项目启动成功.....");
    }
}
```

```java
/**
 * 菜品 管理
 */
@RestController
@RequestMapping("/dish")
@Slf4j
public class DishController {
    @Autowired
    private DishService dishService;
    /**
     * 新增菜品
     */
    @PostMapping
    public R<String> save(@RequestBody DishDto dishDto) {
        dishService.saveWithFlavor(dishDto);
        return null;
    }
}
```

**DishService**

```java
public interface DishService  extends IService<Dish> {
    /**
     * 新增菜品同时添加口味数据
     */
    void saveWithFlavor(DishDto dishDto);

}
```

**DishServiceImpl**

```java
@Service
public class DishServiceImpl extends ServiceImpl<DishMapper, Dish> implements DishService {
    @Autowired
    private DishFlavorService dishFlavorService;
    /**
     * 新增菜品同时添加口味数据
     */
    @Override
    @Transactional  //开启事务
    public void saveWithFlavor(DishDto dishDto) {
        //保存菜品的基本信息到菜品表dish
        this.save(dishDto);
        Long dishId = dishDto.getId(); //菜品ID
        List<DishFlavor> flavors = dishDto.getFlavors(); //菜品口味
        flavors = flavors.stream().map(item -> {
            item.setDishId(dishId);
            return item;
        }).collect(Collectors.toList());
        //保存菜品口味表数据到菜品口味表
        dishFlavorService.saveBatch(flavors);
    }
}
```

#### Ⅲ. 菜品信息分页查询

**需求分析**

>系统中的菜品数据很多的时候，如果在一个页面中全部展示出来会显得比较乱，不便于查看，所以一般的系统中都会以分页的方式来展示列表数据。

**代码开发**

```java
/**
 * 菜品信息分页查询
 */
@GetMapping("/page")
public R<Page> page(Integer page, Integer pageSize, String name) {
    Page<Dish> pageInfo = new Page<Dish>(page, pageSize);
    Page<DishDto> dishDtoPage = new Page<DishDto>(page, pageSize);
    LambdaQueryWrapper<Dish> queryWrapper = new LambdaQueryWrapper<>();
    queryWrapper.like(name != null, Dish::getName, name);    //添加过滤条件
    queryWrapper.orderByDesc(Dish::getCreateTime);  //添加排序条件
    dishService.page(pageInfo, queryWrapper);  // 执行分页查询
    BeanUtils.copyProperties(pageInfo, dishDtoPage, "records");  // 对象拷贝
    List<Dish> records = pageInfo.getRecords();
    List<DishDto> list =  records.stream().map(item -> {
        DishDto dishDto = new DishDto();
        BeanUtils.copyProperties(item, dishDto); // 对象拷贝
        Long categoryId = item.getCategoryId(); // 分类Id
        Category category = categoryService.getById(categoryId); // 根据id查询分类对象
        String categoryName = category.getName();   // 获取名字
        dishDto.setCategoryName(categoryName);   //  把名字设置给DTO
        return dishDto;
    }).collect(Collectors.toList());
    dishDtoPage.setRecords(list);
    return R.success(dishDtoPage);
}
```

#### Ⅳ. 修改菜品

**需求分析**

>在菜品管理列表页面点击修改按钮，跳转到修改菜品页面，在修改页面回显菜品相关信息并进行修改，最后点击确定按钮完成修改操作

**执行过程**

>1、页面发送ajax请求，请求服务端获取分类数据，用于菜品分类下拉框中数据展示
>2、页面发送ajax请求，请求服务端，根据id查询当前菜品信息，用于菜品信息回显
>3、页面发送请求，请求服务端进行图片下载，用于页图片回显
>4、点击保存按钮，页面发送ajax请求，将修改后的菜品相关数据以json形式提交到服务端

**代码开发**

```java
/**
 *  查询当前菜品信息和对应的口味信息 根据Id
 */
@GetMapping("{id}")
public R<DishDto> get(@PathVariable Long id) {
    if (id == null) {
        return R.error("id不能为空");
    }
    DishDto dishDto = dishService.getByIdWithFlavor(id);
    return R.success(dishDto);
}
```

```java
/**
 * 根据Id查询对应的菜品信息和口味信息
 */
@Override
public DishDto getByIdWithFlavor(Long id) {
    // 查询菜品基本信息
    Dish dish = this.getById(id);
    DishDto dishDto = new DishDto();
    BeanUtils.copyProperties(dish,dishDto);
    //查询菜品对应的口味信息
    LambdaQueryWrapper<DishFlavor> queryWrapper = new LambdaQueryWrapper<>();
    queryWrapper.eq(DishFlavor::getDishId, dish.getId());
    List<DishFlavor> dishFlavors = dishFlavorService.list(queryWrapper);
    dishDto.setFlavors(dishFlavors);
    return dishDto;
}
```

```java
/**
 * 修改菜品
 */
@PutMapping
public R<String> update(@RequestBody DishDto dishDto) {
    dishService.updateWithFlavor(dishDto);
    return R.success("新增菜品成功");
}
```

```java
/**
 * 更新菜品信息和口味信息
 */
@Override
public void updateWithFlavor(DishDto dishDto) {
    // 更新Dish表
    this.updateById(dishDto);
    LambdaQueryWrapper<DishFlavor> queryWrapper = new LambdaQueryWrapper<>();
    queryWrapper.eq(DishFlavor::getDishId, dishDto.getId());
    // 清理当前菜品 对应口味数据
    dishFlavorService.remove(queryWrapper);
    // 添加当前提交过来的口味数据
    List<DishFlavor> flavors = dishDto.getFlavors().stream().map(item -> {
        item.setDishId(dishDto.getId());
        return item;
    }).collect(Collectors.toList());
    dishFlavorService.saveBatch(flavors);
}
```

### 4.7 套餐管理开发

#### Ⅰ. 新增套餐

**需求分析**

>套餐就是菜品的集合。
>后台系统中可以管理套餐信息，通过新增套餐功能来添加一个新的套餐，在添加套餐时需要选择当前套餐所属的套餐分类和包含的菜品，并且需要上传套餐对应的图片，在移动端会按照套餐分类来展示对应的套餐。

```java
/**
 * 套餐菜品关系
 */
@Data
public class SetmealDish implements Serializable {
    private static final long serialVersionUID = 1L;
    private Long id;
    //套餐id
    private Long setmealId;
    //菜品id
    private Long dishId;
    //菜品名称 （冗余字段）
    private String name;
    //菜品原价
    private BigDecimal price;
    //份数
    private Integer copies;
    //排序
    private Integer sort;
    @TableField(fill = FieldFill.INSERT)
    private LocalDateTime createTime;
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateTime;
    @TableField(fill = FieldFill.INSERT)
    private Long createUser;
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private Long updateUser;
    //是否删除
    private Integer isDeleted;
}
```

```java
@Data
public class SetmealDto extends Setmeal {
    private List<SetmealDish> setmealDishes;
    private String categoryName;
}
```

**交互过程**

>1、页面(backend/page/combo/add.html)发送ajax请求，请求服务端获取套餐分类数据并展示到下拉框中
>2、页面发送ajax请求，请求服务端获取菜品分类数据并展示到添加菜品窗口中
>3、页面发送ajax请求，请求服务端，根据菜品分类查询对应的菜品数据并展示到添加菜品窗口中
>4、页面发送请求进行图片上传，请求服务端将图片保存到服务器
>5、页面发送请求进行图片下载，将上传的图片进行回显
>6、点击保存按钮，发送ajax请求，将套餐相关数据以json形式提交到服务端



#### Ⅱ. 套餐信息分页查询

#### Ⅲ. 删除套餐





### 4.8 手机验证码登录

```java
/**
 * 用户 控制器
 */
@RestController
@RequestMapping("/user")
public class UserController {
    @Autowired
    private UserService userService;

    /**
     * 发送手机短信验证码
     */
    @PostMapping("/sendMsg")
    public R<String> sendMsg(@RequestBody User user, HttpSession httpSession) {
        String phone = user.getPhone();
        if (StringUtils.isBlank(phone)) {
            return R.error("手机号不能为空");
        }
        // 工具类获取 四位验证码
        String code = ValidateCodeUtils.generateValidateCode(6).toString();
        // 调用API发送短信
		//SMSUtils.sendMessage(phone, code);
        System.err.println("code = " + code);
        // 需要将生成的验证码保存到Session
        httpSession.setAttribute(phone, code);
        return R.error("短信发送成功");
    }
    /**
     * 登录接口
     */
    @PostMapping("/login")
    public R<User> login(@RequestBody Map<Object, Object> map, HttpSession session) {
        // 获取手机号,和code
        String phone = map.get("phone").toString();
        String code = map.get("code").toString();
        // 从session获取保存验证码
        String codeInSession = (String) session.getAttribute(phone);
        System.err.println("code = " + code);
        // 验证码进行比对
        if (codeInSession != null && codeInSession.equals(code)) { // 如果比对成功,则登录成功
            // --- 判断当前用户是否存在,如果不存在则自动注册
            LambdaQueryWrapper<User> queryWrapper = new LambdaQueryWrapper<>();
            queryWrapper.eq(User::getPhone, phone);
            User user = userService.getOne(queryWrapper);
            if (user == null) { //不存在自动注册,新用户自动注册
                user = new User();
                user.setPhone(phone);
                user.setStatus(1);
                userService.save(user);
            }
            session.setAttribute("user", user.getId());
            return R.success(user);
        }
        return R.error("登录失败");
    }
}
```

```java
/**
 * 短信发送工具类
 */
public class SMSUtils {
	/**
	 * 发送短信
	 * @param param 参数
	 */
	public static void sendMessage(String phoneNumbers,String param){
		DefaultProfile profile = DefaultProfile.getProfile("cn-hangzhou", "LTAI5t9TGLqe1Mf3BxpKNse8", "BFK4bYs0NoN3w3H7bXncJkj6uI4iDs");
		IAcsClient client = new DefaultAcsClient(profile);
		SendSmsRequest request = new SendSmsRequest();
		request.setSysRegionId("cn-hangzhou");
		request.setPhoneNumbers(phoneNumbers);
		request.setSignName("测试专用模板");  //signName 签名
		request.setTemplateCode("SMS_154950909"); //templateCode 模板
		request.setTemplateParam("{\"code\":\""+param+"\"}");
		try {
			SendSmsResponse response = client.getAcsResponse(request);
			System.out.println("短信发送成功");
		}catch (ClientException e) {
			e.printStackTrace();
		}
	}
}
```





### 4.9 菜品展示、购物车、下单

#### Ⅰ. 菜品展示

